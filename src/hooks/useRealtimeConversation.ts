// src/hooks/useRealtimeConversation.ts - VERSION CORRIG√âE
import { useEffect, useRef, useState } from 'react'
import { supabase } from '../lib/supabase'
import { useAuth } from '../contexts/AuthContext'
import type { Message, Profile, Conversation } from '../types/database'

interface UseRealtimeConversationProps {
  conversationId: string | null
}

export function useRealtimeConversation({ conversationId }: UseRealtimeConversationProps) {
  const { user } = useAuth()
  const [messages, setMessages] = useState<(Message & { sender: Profile })[]>([])
  const [conversation, setConversation] = useState<Conversation | null>(null)
  const [onlineUsers, setOnlineUsers] = useState<string[]>([])
  const [typingUsers, setTypingUsers] = useState<string[]>([])
  const channelRef = useRef<any>(null)
  const presenceRef = useRef<any>(null)
  const typingTimeoutRef = useRef<NodeJS.Timeout>()

  // ‚úÖ CORRECTION 1 : Meilleure gestion du conversationId
  useEffect(() => {
    if (conversationId) {
      console.log('üîÑ Loading conversation data for:', conversationId)
      loadMessages()
      loadConversation()
    } else {
      console.log('üßπ Resetting conversation state')
      setMessages([])
      setConversation(null)
      setOnlineUsers([])
      setTypingUsers([])
    }
  }, [conversationId])

  // ‚úÖ CORRECTION 2 : Setup realtime avec gestion d'erreurs am√©lior√©e
  useEffect(() => {
    if (!conversationId || !user) {
      console.log('‚ö†Ô∏è No conversation ID or user, skipping realtime setup')
      return
    }

    console.log('üì° Setting up realtime subscriptions for conversation:', conversationId)

    // Cleanup existing subscriptions
    cleanupSubscriptions()

    // ‚úÖ CORRECTION 3 : Channel messages avec retry logic
    channelRef.current = supabase
      .channel(`conversation-${conversationId}`)
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'messages',
        filter: `conversation_id=eq.${conversationId}`
      }, async (payload) => {
        console.log('üì® New message received via realtime:', payload.new.id)
        
        try {
          // Load sender info avec retry en cas d'√©chec
          let sender = null
          let retryCount = 0
          const maxRetries = 3

          while (!sender && retryCount < maxRetries) {
            const { data: senderData, error: senderError } = await supabase
              .from('profiles')
              .select('*')
              .eq('id', payload.new.sender_id)
              .single()

            if (senderError) {
              console.warn(`‚ö†Ô∏è Retry ${retryCount + 1}/${maxRetries} loading sender:`, senderError)
              retryCount++
              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount)) // exponential backoff
            } else {
              sender = senderData
            }
          }

          if (!sender) {
            console.error('‚ùå Failed to load sender after retries')
            return
          }

          const newMessage = {
            ...payload.new,
            sender: sender
          } as Message & { sender: Profile }

          // ‚úÖ CORRECTION 4 : √âviter les doublons avec v√©rification plus robuste
          setMessages(prev => {
            const existingIndex = prev.findIndex(m => m.id === newMessage.id)
            if (existingIndex !== -1) {
              console.log('üîÑ Message already exists, updating:', newMessage.id)
              const updated = [...prev]
              updated[existingIndex] = newMessage
              return updated.sort((a, b) => 
                new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
              )
            }
            
            console.log('‚úÖ Adding new message to state:', newMessage.id)
            const newMessages = [...prev, newMessage].sort((a, b) => 
              new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
            )
            
            // ‚úÖ CORRECTION 5 : Force re-render imm√©diatement
            requestAnimationFrame(() => {
              // Trigger scroll to bottom apr√®s le rendu
              const event = new CustomEvent('new-message-added', { detail: newMessage })
              window.dispatchEvent(event)
            })
            
            return newMessages
          })

          // Mark as read if not sent by current user
          if (payload.new.sender_id !== user.id) {
            console.log('üìñ Marking message as read:', newMessage.id)
            setTimeout(async () => {
              await supabase
                .from('messages')
                .update({ read_at: new Date().toISOString() })
                .eq('id', payload.new.id)
            }, 500) // Small delay to ensure message is rendered
          }

        } catch (error) {
          console.error('‚ùå Error processing new message:', error)
        }
      })
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'conversations',
        filter: `id=eq.${conversationId}`
      }, (payload) => {
        console.log('üí¨ Conversation updated:', payload.new)
        setConversation(prev => prev ? { ...prev, ...payload.new } : null)
      })
      .subscribe((status) => {
        console.log('üì° Message channel status:', status)
        if (status === 'SUBSCRIBED') {
          console.log('‚úÖ Message channel subscribed successfully')
        } else if (status === 'CHANNEL_ERROR') {
          console.error('‚ùå Message channel error, attempting reconnect...')
          // Retry connection after delay
          setTimeout(() => {
            if (conversationId && user) {
              console.log('üîÑ Retrying message channel connection')
              // Re-setup subscriptions
            }
          }, 5000)
        }
      })

    // ‚úÖ CORRECTION 6 : Presence avec reconnection automatique
    presenceRef.current = supabase
      .channel(`presence-conversation-${conversationId}`)
      .on('presence', { event: 'sync' }, () => {
        const state = presenceRef.current?.presenceState()
        if (state) {
          const users = Object.keys(state).map(key => state[key][0]?.user_id).filter(Boolean)
          console.log('üë• Online users updated:', users)
          setOnlineUsers(users)
        }
      })
      .on('broadcast', { event: 'typing' }, ({ payload }) => {
        if (payload.user_id !== user.id) {
          setTypingUsers(prev => {
            if (!prev.includes(payload.user_id)) {
              return [...prev, payload.user_id]
            }
            return prev
          })
          
          setTimeout(() => {
            setTypingUsers(prev => prev.filter(id => id !== payload.user_id))
          }, 3000)
        }
      })
      .on('broadcast', { event: 'stop_typing' }, ({ payload }) => {
        setTypingUsers(prev => prev.filter(id => id !== payload.user_id))
      })
      .subscribe(async (status) => {
        console.log('üì° Presence channel status:', status)
        if (status === 'SUBSCRIBED') {
          console.log('‚úÖ Presence channel subscribed successfully')
          try {
            await presenceRef.current?.track({
              user_id: user.id,
              online_at: new Date().toISOString(),
            })
            console.log('üìç Presence tracked successfully')
          } catch (error) {
            console.error('‚ùå Error tracking presence:', error)
          }
        } else if (status === 'CHANNEL_ERROR') {
          console.error('‚ùå Presence channel error')
        }
      })

    return () => {
      console.log('üßπ Cleaning up realtime subscriptions')
      cleanupSubscriptions()
    }
  }, [conversationId, user])

  const cleanupSubscriptions = () => {
    if (channelRef.current) {
      console.log('üßπ Cleaning up message channel')
      channelRef.current.unsubscribe()
      channelRef.current = null
    }
    if (presenceRef.current) {
      console.log('üßπ Cleaning up presence channel')
      presenceRef.current.unsubscribe()
      presenceRef.current = null
    }
  }

  const loadMessages = async () => {
    if (!conversationId) return

    console.log('üì• Loading messages for conversation:', conversationId)

    try {
      const { data, error } = await supabase
        .from('messages')
        .select(`
          *,
          sender:profiles!messages_sender_id_fkey(*)
        `)
        .eq('conversation_id', conversationId)
        .order('created_at', { ascending: true })

      if (error) {
        console.error('‚ùå Error loading messages:', error)
        throw error
      }

      console.log(`‚úÖ Loaded ${data?.length || 0} messages`)
      setMessages(data || [])
    } catch (error) {
      console.error('‚ùå Error loading messages:', error)
    }
  }

  const loadConversation = async () => {
    if (!conversationId) return

    console.log('üí¨ Loading conversation:', conversationId)

    try {
      const { data, error } = await supabase
        .from('conversations')
        .select(`
          *,
          question:questions!conversations_question_id_fkey(
            *,
            user:profiles!questions_user_id_fkey(*)
          ),
          user:profiles!conversations_user_id_fkey(*),
          judge:profiles!conversations_judge_id_fkey(*)
        `)
        .eq('id', conversationId)
        .single()

      if (error) {
        console.error('‚ùå Error loading conversation:', error)
        throw error
      }

      console.log('‚úÖ Conversation loaded successfully')
      setConversation(data)
    } catch (error) {
      console.error('‚ùå Error loading conversation:', error)
    }
  }

  // ‚úÖ CORRECTION 7 : sendMessage avec meilleure gestion d'erreurs
  const sendMessage = async (content: string, metadata?: any) => {
    if (!conversationId || !user || !content.trim()) {
      console.log('‚ùå Cannot send message: missing data')
      return
    }

    console.log('üì§ Sending message...')

    try {
      const messageData = {
        conversation_id: conversationId,
        sender_id: user.id,
        content: content.trim(),
        message_type: 'text' as const,
        metadata: metadata || null
      }

      const { data, error } = await supabase
        .from('messages')
        .insert(messageData)
        .select(`
          *,
          sender:profiles!messages_sender_id_fkey(*)
        `)
        .single()

      if (error) {
        console.error('‚ùå Error sending message:', error)
        throw error
      }

      console.log('‚úÖ Message sent successfully:', data.id)

      // Update conversation last message time
      await supabase
        .from('conversations')
        .update({ 
          last_message_at: new Date().toISOString()
        })
        .eq('id', conversationId)

      // Stop typing indicator
      if (presenceRef.current) {
        presenceRef.current.send({
          type: 'broadcast',
          event: 'stop_typing',
          payload: { user_id: user.id }
        })
      }

    } catch (error) {
      console.error('‚ùå Error sending message:', error)
      throw error
    }
  }

  const sendTypingIndicator = () => {
    if (!presenceRef.current || !user) return

    presenceRef.current.send({
      type: 'broadcast',
      event: 'typing',
      payload: { user_id: user.id }
    })

    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current)
    }

    typingTimeoutRef.current = setTimeout(() => {
      presenceRef.current?.send({
        type: 'broadcast',
        event: 'stop_typing',
        payload: { user_id: user.id }
      })
    }, 3000)
  }

  return {
    messages,
    conversation,
    onlineUsers,
    typingUsers,
    sendMessage,
    sendTypingIndicator,
    loadMessages,
    loadConversation
  }
}